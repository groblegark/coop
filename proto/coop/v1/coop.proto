// SPDX-License-Identifier: BUSL-1.1
// Copyright 2025 Alfred Jean LLC

syntax = "proto3";
package coop.v1;

option go_package = "github.com/anthropics/gas-town/gen/coop/v1;coopv1";

// Terminal session management and agent orchestration API.
service Coop {
  // Terminal

  // Health check. Always available.
  rpc GetHealth(GetHealthRequest) returns (GetHealthResponse);
  // Rendered terminal screen content.
  rpc GetScreen(GetScreenRequest) returns (GetScreenResponse);
  // Session status summary.
  rpc GetStatus(GetStatusRequest) returns (GetStatusResponse);
  // Write text to the PTY.
  rpc SendInput(SendInputRequest) returns (SendInputResponse);
  // Send named key sequences to the PTY.
  rpc SendKeys(SendKeysRequest) returns (SendKeysResponse);
  // Resize the PTY.
  rpc Resize(ResizeRequest) returns (ResizeResponse);
  // Send a signal to the child process.
  rpc SendSignal(SendSignalRequest) returns (SendSignalResponse);
  // Stream raw PTY output bytes starting from a byte offset.
  rpc StreamOutput(StreamOutputRequest) returns (stream OutputChunk);
  // Stream rendered terminal screen snapshots on each update.
  rpc StreamScreen(StreamScreenRequest) returns (stream ScreenSnapshot);

  // Agent (requires --agent flag)

  // Current agent state and prompt context.
  rpc GetAgentState(GetAgentStateRequest) returns (GetAgentStateResponse);
  // Send a follow-up message. Only succeeds when state is waiting_for_input.
  rpc Nudge(NudgeRequest) returns (NudgeResponse);
  // Respond to an active prompt (permission, plan, or question).
  rpc Respond(RespondRequest) returns (RespondResponse);
  // Stream agent state transitions in real time.
  rpc StreamState(StreamStateRequest) returns (stream AgentStateEvent);

  // Stop hook management

  // Resolve a pending stop gate so the agent is allowed to stop.
  rpc ResolveStop(ResolveStopRequest) returns (ResolveStopResponse);
  // Update the stop hook configuration at runtime.
  rpc PutStopConfig(PutStopConfigRequest) returns (PutStopConfigResponse);
  // Read the current stop hook configuration.
  rpc GetStopConfig(GetStopConfigRequest) returns (GetStopConfigResponse);
  // Stream stop hook verdict events in real time.
  rpc StreamStopEvents(StreamStopEventsRequest) returns (stream StopEvent);
}

// --- Terminal messages ---

message GetHealthRequest {}
message GetHealthResponse {
  // Always "running".
  string status = 1;
  // Child process PID, absent if not yet spawned.
  optional int32 pid = 2;
  // Seconds since coop started.
  int64 uptime_secs = 3;
  // Agent type: "claude", "codex", "gemini", "unknown".
  string agent = 4;
  // Number of connected WebSocket clients.
  int32 ws_clients = 5;
}

message GetScreenRequest {
  enum Format {
    // Plain text (default).
    TEXT = 0;
    // Text with ANSI escape sequences.
    ANSI = 1;
  }
  Format format = 1;
  // Include cursor position in the response.
  bool include_cursor = 2;
}

message GetScreenResponse {
  // One string per terminal row.
  repeated string lines = 1;
  // Terminal width.
  int32 cols = 2;
  // Terminal height.
  int32 rows = 3;
  // Whether the alternate screen buffer is active.
  bool alt_screen = 4;
  // Cursor position (only present when include_cursor is true).
  CursorPosition cursor = 5;
  // Monotonic screen update seq number.
  uint64 seq = 6;
}

// 0-indexed cursor position within the terminal grid.
message CursorPosition {
  int32 row = 1;
  int32 col = 2;
}

message GetStatusRequest {}
message GetStatusResponse {
  // Session state: "starting", "running", or "exited".
  string state = 1;
  // Child process PID.
  optional int32 pid = 2;
  // Seconds since coop started.
  int64 uptime_secs = 3;
  // Exit code if the process has exited.
  optional int32 exit_code = 4;
  // Current screen seq number.
  uint64 screen_seq = 5;
  // Total bytes read from PTY.
  uint64 bytes_read = 6;
  // Total bytes written to PTY.
  uint64 bytes_written = 7;
  // Number of connected WebSocket clients.
  int32 ws_clients = 8;
}

message SendInputRequest {
  // Text to write to the PTY.
  string text = 1;
  // Append carriage return after text.
  bool enter = 2;
}
message SendInputResponse {
  int32 bytes_written = 1;
}

// Named key sequences (case-insensitive). Supported: enter, tab, escape,
// backspace, delete, space, up, down, left, right, home, end, pageup,
// pagedown, insert, f1-f12, ctrl-{a..z}.
message SendKeysRequest {
  repeated string keys = 1;
}
message SendKeysResponse {
  int32 bytes_written = 1;
}

message ResizeRequest {
  // New column count (must be > 0).
  int32 cols = 1;
  // New row count (must be > 0).
  int32 rows = 2;
}
message ResizeResponse {
  int32 cols = 1;
  int32 rows = 2;
}

// Signal name (case-insensitive): HUP, INT, QUIT, KILL, USR1, USR2, TERM,
// CONT, STOP, TSTP, WINCH. Accepts bare names, SIG-prefixed, or numbers.
message SendSignalRequest {
  string signal = 1;
}
message SendSignalResponse {
  bool delivered = 1;
}

message StreamOutputRequest {
  // Byte offset to start streaming from.
  uint64 from_offset = 1;
}
message OutputChunk {
  // Raw PTY output bytes.
  bytes data = 1;
  // Byte offset in the output stream.
  uint64 offset = 2;
}

message StreamScreenRequest {}
message ScreenSnapshot {
  repeated string lines = 1;
  int32 cols = 2;
  int32 rows = 3;
  bool alt_screen = 4;
  CursorPosition cursor = 5;
  uint64 seq = 6;
}

// --- Agent messages ---

// A single question within a multi-question dialog.
message QuestionContext {
  // The question text.
  string question = 1;
  // Available option labels.
  repeated string options = 2;
}

// An answer to a single question within a dialog.
message QuestionAnswer {
  // 1-indexed option number.
  optional int32 option = 1;
  // Freeform text (used when selecting "Other").
  optional string text = 2;
}

// Contextual information about a prompt the agent is presenting.
// Present when agent state is "prompt".
message PromptContext {
  // Prompt type: "permission", "plan", "question".
  string type = 1;
  // Tool name (permission prompts).
  optional string tool = 2;
  // Truncated tool input JSON (permission prompts).
  optional string input_preview = 3;
  // Raw screen lines (plan prompts).
  repeated string screen_lines = 7;
  // All questions in a multi-question dialog.
  repeated QuestionContext questions = 8;
  // 0-indexed current question; equals questions count at confirm phase.
  uint32 question_current = 9;
}

message GetAgentStateRequest {}
message GetAgentStateResponse {
  // Agent type.
  string agent = 1;
  // Current agent state: starting, working, waiting_for_input,
  // prompt, error, exited, unknown.
  string state = 2;
  // Sequence number when this state was entered.
  uint64 since_seq = 3;
  // Current screen sequence number.
  uint64 screen_seq = 4;
  // Which detection tier produced this state.
  string detection_tier = 5;
  // Prompt context (present for prompt states).
  optional PromptContext prompt = 6;
  // Seconds remaining on the idle grace timer.
  optional float idle_grace_remaining_secs = 7;
  // Error description (when state is "error").
  optional string error_detail = 8;
  // Error classification (when state is "error").
  optional string error_category = 9;
}

message NudgeRequest {
  // Text message to send to the agent.
  string message = 1;
}
message NudgeResponse {
  // Whether the nudge was written to the PTY.
  bool delivered = 1;
  // Agent state at the time of the request.
  string state_before = 2;
  // Why the nudge was not delivered.
  optional string reason = 3;
}

// Respond to an active prompt. Fields used depend on the current agent state:
//   permission_prompt: accept
//   plan_prompt: accept, text (feedback on reject)
//   question: answers
message RespondRequest {
  // Accept/deny (permission and plan prompts).
  optional bool accept = 1;
  // Freeform text (plan rejection feedback).
  optional string text = 3;
  // Structured answers for multi-question dialogs.
  repeated QuestionAnswer answers = 4;
}
message RespondResponse {
  // Whether the response was written to the PTY.
  bool delivered = 1;
  // Agent state at the time of the request.
  string prompt_type = 2;
  // Why the response was not delivered.
  optional string reason = 3;
}

message StreamStateRequest {}

// --- Stop hook messages ---

message ResolveStopRequest {
  // JSON body of the signal (freeform).
  string body_json = 1;
}
message ResolveStopResponse {
  bool accepted = 1;
}

message PutStopConfigRequest {
  // StopConfig as JSON.
  string config_json = 1;
}
message PutStopConfigResponse {
  bool updated = 1;
}

message GetStopConfigRequest {}
message GetStopConfigResponse {
  // Current StopConfig as JSON.
  string config_json = 1;
}

message StreamStopEventsRequest {}
// Stop hook verdict event.
message StopEvent {
  // Verdict type: signaled, error, safety_valve, blocked, allowed.
  string stop_type = 1;
  // Signal body JSON (when stop_type is "signaled").
  optional string signal_json = 2;
  // Error description (when stop_type is "error").
  optional string error_detail = 3;
  // Monotonic sequence number.
  uint64 seq = 4;
}

// Agent state transition event.
message AgentStateEvent {
  // Previous agent state.
  string prev = 1;
  // New agent state.
  string next = 2;
  // State sequence number.
  uint64 seq = 3;
  // Prompt context (for prompt states).
  optional PromptContext prompt = 4;
  // Error text (when next is "error").
  optional string error_detail = 5;
  // Error classification (when next is "error").
  optional string error_category = 6;
}
