<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Coop Multiplexer</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/css/xterm.css" />
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { height: 100%; background: #1e1e1e; overflow: hidden; font-family: Menlo, Monaco, monospace; }

  /* Header bar */
  #header {
    height: 32px; line-height: 32px; padding: 0 12px;
    background: #111; border-bottom: 1px solid #333;
    display: flex; align-items: center; justify-content: space-between;
    font-size: 12px; color: #aaa;
  }
  #header .stats { display: flex; gap: 16px; }
  .stat-label { color: #666; }
  .stat-value { color: #ccc; font-weight: 600; }
  .stat-value.healthy { color: #4ec950; }
  .stat-value.alert { color: #e06060; }

  /* Grid of session tiles */
  #grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(420px, 1fr));
    gap: 4px;
    padding: 4px;
    height: calc(100% - 32px - 24px);
    overflow-y: auto;
  }

  /* Session tile */
  .session-tile {
    background: #181818;
    border: 1px solid #333;
    border-radius: 4px;
    display: flex;
    flex-direction: column;
    min-height: 200px;
    overflow: hidden;
    cursor: pointer;
    transition: border-color 0.15s;
  }
  .session-tile:hover { border-color: #555; }
  .session-tile.focused { border-color: #7cb7ff; }
  .session-tile.expanded {
    position: fixed; top: 32px; left: 0; right: 0; bottom: 24px;
    z-index: 50; border-radius: 0; border-color: #7cb7ff;
    min-height: auto;
  }

  /* Tile header */
  .session-header {
    display: flex; align-items: center; gap: 8px;
    padding: 4px 8px; background: #151515;
    border-bottom: 1px solid #2a2a2a;
    font-size: 11px; flex-shrink: 0;
  }
  .session-name { font-weight: 600; color: #ccc; }
  .session-badge {
    font-size: 10px; padding: 1px 6px;
    border-radius: 3px; border: 1px solid;
    font-weight: 600;
  }
  .session-badge.working { border-color: #4e8; color: #4e8; }
  .session-badge.idle { border-color: #e8a317; color: #e8a317; }
  .session-badge.prompt { border-color: #7cb7ff; color: #7cb7ff; }
  .session-badge.error { border-color: #e06060; color: #e06060; }
  .session-badge.exited { border-color: #888; color: #888; }
  .session-badge.starting { border-color: #b8a0e8; color: #b8a0e8; }
  .session-badge.offline { border-color: #555; color: #555; }
  .cred-indicator {
    font-size: 10px; margin-left: auto; color: #666;
  }
  .cred-indicator.alert { color: #e06060; font-weight: 600; }
  .expand-btn {
    background: none; border: 1px solid #444; color: #888;
    font: 10px monospace; padding: 1px 6px; cursor: pointer;
    border-radius: 3px; margin-left: 4px;
  }
  .expand-btn:hover { border-color: #888; color: #ccc; }

  /* Terminal area in tile */
  .session-terminal {
    flex: 1;
    padding: 2px;
    min-height: 0;
    overflow: hidden;
  }

  /* Status bar */
  #status {
    height: 24px; line-height: 24px; padding: 0 8px;
    font: 12px/24px monospace; color: #ccc; background: #111;
    display: flex; justify-content: space-between; align-items: center;
    flex-shrink: 0;
  }
  .dot {
    display: inline-block; width: 8px; height: 8px; border-radius: 50%;
    margin-right: 6px; vertical-align: middle;
  }
  .dot-connected { background: #4ec950; }
  .dot-connecting { background: #e8a317; }
  .dot-disconnected { background: #e04040; }

  /* Empty state */
  #empty {
    display: none; text-align: center; padding: 60px 20px;
    color: #555; font-size: 14px;
  }
  #empty.visible { display: block; }
</style>
</head>
<body>
<div id="header">
  <span style="font-weight:600;color:#ccc;">Coop Multiplexer</span>
  <div class="stats">
    <span><span class="stat-label">Sessions:</span> <span class="stat-value" id="stat-total">0</span></span>
    <span><span class="stat-label">Healthy:</span> <span class="stat-value healthy" id="stat-healthy">0</span></span>
    <span><span class="stat-label">Alerts:</span> <span class="stat-value" id="stat-alerts">0</span></span>
  </div>
</div>
<div id="grid">
  <div id="empty" class="visible">No sessions connected. Waiting for agents to register...</div>
</div>
<div id="status">
  <span>
    <span id="dot" class="dot dot-connecting"></span>
    <span id="label">Connecting...</span>
  </span>
  <span id="info"></span>
</div>

<script type="module">
import { FitAddon } from 'https://cdn.jsdelivr.net/npm/@xterm/addon-fit@0.10.0/+esm';
import { WebglAddon } from 'https://cdn.jsdelivr.net/npm/@xterm/addon-webgl@0.18.0/+esm';
import { Terminal } from 'https://cdn.jsdelivr.net/npm/@xterm/xterm@5.5.0/+esm';

const wsProto = location.protocol === 'https:' ? 'wss:' : 'ws:';
const AUTH_TOKEN = new URLSearchParams(location.search).get('token') || '';
const tokenParam = AUTH_TOKEN ? `&token=${encodeURIComponent(AUTH_TOKEN)}` : '';
const WS_URL = `${wsProto}//${location.host}/ws/mux?subscribe=state,screen,credentials${tokenParam}`;

const grid = document.getElementById('grid');
const empty = document.getElementById('empty');
const dot = document.getElementById('dot');
const lbl = document.getElementById('label');
const infoEl = document.getElementById('info');

const sessions = new Map();
let focusedSession = null;
let expandedSession = null;

function syncSessionResize(sessionId) {
  const s = sessions.get(sessionId);
  if (!s) return;
  const cols = s.term.cols;
  const rows = s.term.rows;
  if (cols === s.lastCols && rows === s.lastRows) return;
  s.lastCols = cols;
  s.lastRows = rows;
  if (s.resizeTimer) clearTimeout(s.resizeTimer);
  s.resizeTimer = setTimeout(() => {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ event: 'resize', session: sessionId, cols, rows }));
    }
  }, 250);
}

function fitAndSync(sessionId) {
  const s = sessions.get(sessionId);
  if (!s) return;
  s.fitAddon.fit();
  syncSessionResize(sessionId);
}

function setStatus(state, text) {
  dot.className = `dot dot-${state}`;
  lbl.textContent = text;
}

function updateStats() {
  const total = sessions.size;
  let healthy = 0, alerts = 0;
  for (const [, s] of sessions) {
    if (s.credStatus === 'alert') alerts++;
    if (s.state && s.state !== 'offline' && s.state !== 'error' && s.state !== 'exited') healthy++;
  }
  document.getElementById('stat-total').textContent = total;
  document.getElementById('stat-healthy').textContent = healthy;
  const alertEl = document.getElementById('stat-alerts');
  alertEl.textContent = alerts;
  alertEl.className = `stat-value${alerts > 0 ? ' alert' : ''}`;
  empty.classList.toggle('visible', total === 0);
}

function createSessionTile(sessionId) {
  const tile = document.createElement('div');
  tile.className = 'session-tile';
  tile.dataset.session = sessionId;

  const header = document.createElement('div');
  header.className = 'session-header';

  const name = document.createElement('span');
  name.className = 'session-name';
  name.textContent = sessionId;

  const badge = document.createElement('span');
  badge.className = 'session-badge starting';
  badge.textContent = 'starting';

  const cred = document.createElement('span');
  cred.className = 'cred-indicator';

  const expandBtn = document.createElement('button');
  expandBtn.className = 'expand-btn';
  expandBtn.textContent = '\u2922';
  expandBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    toggleExpand(sessionId);
  });

  header.appendChild(name);
  header.appendChild(badge);
  header.appendChild(cred);
  header.appendChild(expandBtn);

  const termContainer = document.createElement('div');
  termContainer.className = 'session-terminal';

  tile.appendChild(header);
  tile.appendChild(termContainer);

  tile.addEventListener('click', () => setFocus(sessionId));

  grid.appendChild(tile);

  const term = new Terminal({
    cursorBlink: false,
    scrollback: 500,
    fontFamily: 'Menlo, Monaco, "Courier New", monospace',
    fontSize: 11,
    theme: { background: '#181818' },
    disableStdin: true,
  });
  const fitAddon = new FitAddon();
  term.loadAddon(fitAddon);
  term.open(termContainer);

  try {
    const webgl = new WebglAddon();
    webgl.onContextLoss(() => webgl.dispose());
    term.loadAddon(webgl);
  } catch (_) {}

  requestAnimationFrame(() => fitAndSync(sessionId));

  term.onData((str) => {
    if (focusedSession === sessionId && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ event: 'input:send', session: sessionId, text: str }));
    }
  });

  const sessionState = {
    tile, term, fitAddon, badge, cred,
    state: 'starting',
    credStatus: 'ok',
    lastCols: 0,
    lastRows: 0,
    resizeTimer: null,
  };
  sessions.set(sessionId, sessionState);
  updateStats();
  return sessionState;
}

function removeSessionTile(sessionId) {
  const s = sessions.get(sessionId);
  if (!s) return;
  s.term.dispose();
  s.tile.remove();
  sessions.delete(sessionId);
  if (focusedSession === sessionId) focusedSession = null;
  if (expandedSession === sessionId) expandedSession = null;
  updateStats();
}

function setFocus(sessionId) {
  if (focusedSession) {
    const prev = sessions.get(focusedSession);
    if (prev) {
      prev.tile.classList.remove('focused');
      prev.term.options.disableStdin = true;
    }
  }
  focusedSession = sessionId;
  const s = sessions.get(sessionId);
  if (s) {
    s.tile.classList.add('focused');
    s.term.options.disableStdin = false;
    s.term.focus();
  }
}

function toggleExpand(sessionId) {
  if (expandedSession === sessionId) {
    const s = sessions.get(sessionId);
    if (s) {
      s.tile.classList.remove('expanded');
      requestAnimationFrame(() => fitAndSync(sessionId));
    }
    expandedSession = null;
  } else {
    if (expandedSession) {
      const prevId = expandedSession;
      const prev = sessions.get(prevId);
      if (prev) {
        prev.tile.classList.remove('expanded');
        requestAnimationFrame(() => fitAndSync(prevId));
      }
    }
    expandedSession = sessionId;
    const s = sessions.get(sessionId);
    if (s) {
      s.tile.classList.add('expanded');
      setFocus(sessionId);
      requestAnimationFrame(() => fitAndSync(sessionId));
    }
  }
}

function updateBadge(s, state) {
  s.state = state;
  s.badge.textContent = state;
  s.badge.className = `session-badge ${state}`;
  updateStats();
}

function updateCredStatus(s, status) {
  if (status === 'refresh_failed' || status === 'revoked' || status === 'reauth_required') {
    s.credStatus = 'alert';
    s.cred.textContent = '\u26a0 auth';
    s.cred.className = 'cred-indicator alert';
  } else {
    s.credStatus = 'ok';
    s.cred.textContent = '';
    s.cred.className = 'cred-indicator';
  }
  updateStats();
}

function writeScreen(s, lines) {
  s.term.reset();
  const text = lines.join('\r\n');
  s.term.write(text);
}

let ws = null;

function connect() {
  setStatus('connecting', 'Connecting...');
  ws = new WebSocket(WS_URL);

  ws.onopen = () => {
    setStatus('connected', `Connected - ${location.host}`);
  };

  ws.onmessage = (ev) => {
    let msg;
    try { msg = JSON.parse(ev.data); } catch (_) { return; }

    const type = msg.type;
    const sessionId = msg.session;

    if (type === 'session_online') {
      if (!sessions.has(sessionId)) createSessionTile(sessionId);
      return;
    }

    if (type === 'session_offline') {
      const s = sessions.get(sessionId);
      if (s) updateBadge(s, 'offline');
      return;
    }

    if (type === 'state') {
      let s = sessions.get(sessionId);
      if (!s) s = createSessionTile(sessionId);
      updateBadge(s, msg.next || 'unknown');
      return;
    }

    if (type === 'screen') {
      let s = sessions.get(sessionId);
      if (!s) s = createSessionTile(sessionId);
      writeScreen(s, msg.lines || []);
      return;
    }

    if (type === 'credential') {
      let s = sessions.get(sessionId);
      if (!s) s = createSessionTile(sessionId);
      updateCredStatus(s, msg.status || '');
      return;
    }

    if (type === 'error') {
      infoEl.textContent = msg.message || 'error';
    }
  };

  ws.onclose = () => {
    setStatus('disconnected', 'Disconnected');
    setTimeout(connect, 2000);
  };

  ws.onerror = () => {};
}

window.addEventListener('resize', () => {
  for (const [id] of sessions) fitAndSync(id);
});

window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && expandedSession) toggleExpand(expandedSession);
});

connect();
</script>
</body>
</html>
