// SPDX-License-Identifier: BUSL-1.1
// Copyright (c) 2026 Alfred Jean LLC

use serde_json::json;

use crate::driver::AgentState;

use super::{extract_assistant_text, format_claude_cause, parse_claude_state};

#[yare::parameterized(
    error_string = {
        json!({ "error": "rate_limit_exceeded" }),
        Some(AgentState::Error { detail: "rate_limit_exceeded".to_string() })
    },
    error_non_string = {
        json!({ "error": 42 }),
        Some(AgentState::Error { detail: "unknown".to_string() })
    },
    system_message = {
        json!({ "type": "system", "message": { "content": [] } }),
        None
    },
    progress_hook = {
        json!({ "type": "progress", "data": { "type": "hook_progress", "hookEvent": "Stop" } }),
        None
    },
    file_history_snapshot = {
        json!({ "type": "file-history-snapshot", "snapshot": {} }),
        None
    },
    user_message = {
        json!({ "type": "user", "message": { "content": [{ "type": "text", "text": "hello" }] } }),
        Some(AgentState::Working)
    },
    user_meta_message = {
        json!({ "type": "user", "isMeta": true, "message": { "role": "user", "content": "<local-command-caveat>Caveat: The messages below were generated by the user while running local commands.</local-command-caveat>" } }),
        None
    },
    user_local_command = {
        json!({ "type": "user", "message": { "role": "user", "content": "<command-name>/model</command-name>\n            <command-message>model</command-message>\n            <command-args></command-args>" } }),
        None
    },
    user_local_command_stdout = {
        json!({ "type": "user", "message": { "role": "user", "content": "<local-command-stdout>Set model to opus</local-command-stdout>" } }),
        None
    },
    user_interrupt = {
        json!({ "type": "user", "message": { "content": [{ "type": "text", "text": "[Request interrupted by user]" }] } }),
        Some(AgentState::Idle)
    },
    user_rejected_tool = {
        json!({ "type": "user", "toolUseResult": "User rejected tool use", "message": { "content": [{ "type": "tool_result", "content": "The user doesn't want to proceed with this tool use.", "is_error": true, "tool_use_id": "toolu_123" }] } }),
        Some(AgentState::Idle)
    },
    assistant_tool_use = {
        json!({ "type": "assistant", "message": { "content": [{ "type": "tool_use", "name": "Bash", "input": { "command": "ls" } }] } }),
        Some(AgentState::Working)
    },
    assistant_thinking = {
        json!({ "type": "assistant", "message": { "content": [{ "type": "thinking", "thinking": "Let me consider..." }] } }),
        Some(AgentState::Working)
    },
    assistant_text_only = {
        json!({ "type": "assistant", "message": { "content": [{ "type": "text", "text": "Here is the result." }] } }),
        Some(AgentState::Idle)
    },
    empty_content = {
        json!({ "type": "assistant", "message": { "content": [] } }),
        Some(AgentState::Idle)
    },
    missing_message = {
        json!({ "type": "assistant" }),
        None
    },
    missing_content = {
        json!({ "type": "assistant", "message": {} }),
        None
    },
)]
fn state_from_jsonl(entry: serde_json::Value, expected: Option<AgentState>) {
    assert_eq!(parse_claude_state(&entry), expected);
}

#[test]
fn assistant_with_ask_user_produces_question() {
    let entry = json!({
        "type": "assistant",
        "message": {
            "content": [{
                "type": "tool_use",
                "name": "AskUserQuestion",
                "input": {
                    "questions": [{
                        "question": "Which database?",
                        "options": [
                            { "label": "PostgreSQL" },
                            { "label": "SQLite" }
                        ]
                    }]
                }
            }]
        }
    });
    let state = parse_claude_state(&entry);
    match state {
        Some(AgentState::Prompt { prompt }) => {
            assert_eq!(prompt.kind, crate::driver::PromptKind::Question);
            assert_eq!(prompt.questions.len(), 1);
            assert_eq!(prompt.questions[0].question, "Which database?");
            assert_eq!(prompt.questions[0].options, vec!["PostgreSQL", "SQLite"]);
        }
        other => panic!("expected Prompt(Question), got {other:?}"),
    }
}

#[yare::parameterized(
    non_assistant_returns_none = {
        json!({ "type": "user", "message": { "content": [{ "type": "text", "text": "hello" }] } }),
        None
    },
    error_returns_none = {
        json!({ "error": "rate_limit_exceeded" }),
        None
    },
    single_text_block = {
        json!({ "type": "assistant", "message": { "content": [{ "type": "text", "text": "Hello world" }] } }),
        Some("Hello world".to_owned())
    },
    multiple_text_blocks = {
        json!({ "type": "assistant", "message": { "content": [
            { "type": "text", "text": "Line one" },
            { "type": "text", "text": "Line two" }
        ] } }),
        Some("Line one\nLine two".to_owned())
    },
    tool_use_only = {
        json!({ "type": "assistant", "message": { "content": [
            { "type": "tool_use", "name": "Bash", "input": {} }
        ] } }),
        None
    },
    thinking_only = {
        json!({ "type": "assistant", "message": { "content": [
            { "type": "thinking", "thinking": "hmm" }
        ] } }),
        None
    },
    mixed_text_and_tool = {
        json!({ "type": "assistant", "message": { "content": [
            { "type": "text", "text": "Let me run that." },
            { "type": "tool_use", "name": "Bash", "input": {} }
        ] } }),
        Some("Let me run that.".to_owned())
    },
    empty_content = {
        json!({ "type": "assistant", "message": { "content": [] } }),
        None
    },
    missing_message = {
        json!({ "type": "assistant" }),
        None
    },
)]
fn assistant_text_extraction(entry: serde_json::Value, expected: Option<String>) {
    assert_eq!(extract_assistant_text(&entry), expected);
}

#[test]
fn cause_for_user_interrupt_is_log_user() {
    let entry = json!({
        "type": "user",
        "message": { "content": [{ "type": "text", "text": "[Request interrupted by user]" }] }
    });
    assert_eq!(format_claude_cause(&entry, "log"), "log:user");
}

#[test]
fn cause_for_normal_user_message_is_log_user() {
    let entry = json!({
        "type": "user",
        "message": { "content": [{ "type": "text", "text": "hello" }] }
    });
    assert_eq!(format_claude_cause(&entry, "log"), "log:user");
}
